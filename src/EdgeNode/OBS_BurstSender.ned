//
// Copyright (C) 2010-2012 Javier Armendariz Silva, Naiara Garcia Royo
// Copyright (C) 2010-2012 Universidad Publica de Navarra
//
// This file is part of OBSModules.
//
// OBSModules is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// OBSModules is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with OBSModules.  If not, see <http://www.gnu.org/licenses/>.
//

package datacenterssimulation.src.EdgeNode;

//
// Implements a signalling protocol and sends the burst to the first channel available.
//
//   This method can receive two kinds of messages: optical bursts generated by any burstifier or a self-messsage identified by its kind number (see enum). The self-message has a control info object which contains some useful info for the sender such as burst's assigned lambda, burst identifier in scheduledBurst queue, etc.
//   First of all, this method checks the class of message it receives: if it's an optical burst, looks for the data channel (lambda) with the smallest horizon. Then, creates a OBS_BurstSenderInfo, fills it and sends it yourself in order to schedule the BCP sending. Also, stores the burst into scheduledBurst list with an estimated send time (but if scheduledBurst list is limited with maxSchedBurstSize or maxSchedBurstElems, burst will be dropped and deleted when scheduledBurst is full) . At this point, two cases could happen scheduling iniBCP transmission:
//
//   - Data channel is free on current simTime + maxOffset, so the BCP can be sent right now.
//   - It must wait a time until data channel is free, so it needs to delay the BCP sending until maxOffset time before burst transmission.
//
//Once the iniBCP is scheduled, the process continues when this method receives a self-message. Each self-message kind represents a step on a sequence of message sending: first, the BCP begin is sent. After that, a time after (depending on the data rate and size of the message), sends the BCP end message and schedules the burst transmission using the time estimated at the beginning. Finally, once the burst beginning is sent, schedules the burst end using data rate and burst size.
//
simple OBS_BurstSender
{
    parameters:
  
   
        int numQueues; // Number of burstifier queues (should be the same as the dispatcher rules and the output gates).
   
   
   		string sourceAddress;
   	 	string controllerAddress;
   		
        int numChannelFastSwitch; // Number of output data channels (control channel not included).
        
   		int numChannelSlowSwitch; // Number of output data channels (control channel not included).     
       
        double dataRate @unit(bps); // Data rate of the optical channels.
        int BCPSize @unit(B); // Size of the BCP.
        int maxSchedBurstSize @unit(B); // Maximum size of scheduled burst queue (0 = infinity).
        int maxSchedBurstElems; // Maximum number of elements of scheduled burst queue (0 = infinity).
        double guardTime @unit(s); // Offset placed between consecutive burst transmissions.
        bool testing; // If true, module won't try to register itself (use to test this module outside the Edge Node).
        @signal[sentBurstsSlowPath](type=cPacket);
        @signal[sentBurstsFastPath](type=cPacket);
        
        
        
        @signal[sentControlPk](type=cPacket);
        @signal[rcvdControlPk](type=cPacket);


 		@signal[NegativeDelay](type=cPacket);
        @statistic[NegativeDelay](title="Negative Delay"; source=NegativeDelay; record=count; interpolationmode=none);
        

        @signal[rcvdControlPkBid](type=cPacket);
        @statistic[rcvdControlPkBid](title="Control packets received"; source=rcvdControlPkBid; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
        @statistic[rcvdControlPkBidLifetime](title="Control Packets round trip delay"; source="messageAge(rcvdControlPkBid)"; unit=s; record=stats; interpolationmode=none);
        
        @statistic[rcvdControlPk](title="Control packets received"; source=rcvdControlPk; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
        @statistic[rcvdControlPkLifetime](title="Control Packets round trip delay"; source="messageAge(rcvdControlPk)"; unit=s; record=stats; interpolationmode=none);

        @statistic[sentBurstsSlowPath](title="Bursts sent Slow Path"; source=sentBurstsSlowPath; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
        @statistic[sentBurstsFastPath](title="Bursts sent Fast Path"; source=sentBurstsFastPath; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
        
        
        
        
	    @statistic[sentControlPk](title="Control packets sent"; source=sentControlPk; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
	    
    gates:
        input in[];
        output outburstifier[];
       	input controlIn;
		output controlOut;
	//	output outfast[];
		//output outslow[];
	
	    inout physSlow[];
        inout physFast[];
  
		output outdisassembler;	
		
		
        
}

